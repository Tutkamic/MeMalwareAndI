using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using System.Linq;
using System;

public enum Direction
{
    Up,
    UpRight,
    Right,
    DownRight,
    Down,
    DownLeft,
    Left,
    UpLeft
}
public class WallsCreate : MonoBehaviour
{
    private List<FloorTile> floortiles;
    [SerializeField] LayerMask layermask;
    [SerializeField] GameObject wall;
    [SerializeField] GameObject corner;

    Vector3[] dir = {
        new Vector3(0,0,1),
        new Vector3(1,0,1),
        new Vector3(1,0,0),
        new Vector3(1,0,-1),
        new Vector3(0,0,-1),
        new Vector3(-1,0,-1),
        new Vector3(-1,0,0),
        new Vector3(-1,0,1)
    };

    bool[] raycastHit = new bool[8];

    void Start()
    {
        floortiles = FindObjectsOfType<FloorTile>().ToList();
        FindBorderTiles();
    }

    private void FindBorderTiles()
    {
        foreach (var tile in floortiles)
        {
            for (int i = 0; i < 8; i++) raycastHit[i] = Physics.Raycast(tile.gameObject.transform.position, dir[i], 0.72f, layermask);

            FindBorder(tile);
            FindCorners(tile);
        }
    }

    private void FindBorder(FloorTile tile)
    {
        if (!raycastHit[(int)Direction.Up])
        {
            var pos = new Vector3(tile.transform.position.x, 1, tile.transform.position.z + 0.5f);
            Instantiate(wall, pos, Quaternion.Euler(0, 90, 90));
        }
        if (!raycastHit[(int)Direction.Right])
        {
            var pos = new Vector3(tile.transform.position.x + 0.5f, 1, tile.transform.position.z);
            Instantiate(wall, pos, Quaternion.Euler(0, 0, 90));
        }
        if (!raycastHit[(int)Direction.Down])
        {
            var pos = new Vector3(tile.transform.position.x, 1, tile.transform.position.z - 0.5f);
            Instantiate(wall, pos, Quaternion.Euler(0, 90, 90));
        }
        if (!raycastHit[(int)Direction.Left])
        {
            var pos = new Vector3(tile.transform.position.x - 0.5f, 1, tile.transform.position.z);
            Instantiate(wall, pos, Quaternion.Euler(0, 0, 90));
        }
    }

    private void FindCorners(FloorTile tile)
    {
        if (!raycastHit[(int)Direction.UpRight])
        {
            if ((!raycastHit[(int)Direction.Up] && !raycastHit[(int)Direction.Right]) || (raycastHit[(int)Direction.Up] && raycastHit[(int)Direction.Right]))
            {
                var pos = new Vector3(tile.transform.position.x + 0.5f, 1, tile.transform.position.z + 0.5f);
                Instantiate(corner, pos, Quaternion.Euler(0, 0, 0));
            }
        }
        if (!raycastHit[(int)Direction.DownRight])
        {
            if ((!raycastHit[(int)Direction.Down] && !raycastHit[(int)Direction.Right]) || (raycastHit[(int)Direction.Down] && raycastHit[(int)Direction.Right]))
            {
                var pos = new Vector3(tile.transform.position.x + 0.5f, 1, tile.transform.position.z - 0.5f);
                Instantiate(corner, pos, Quaternion.Euler(0, 0, 0));
            }
        }
        if (!raycastHit[(int)Direction.DownLeft])
        {
            if ((!raycastHit[(int)Direction.Down] && !raycastHit[(int)Direction.Left]) || (raycastHit[(int)Direction.Down] && raycastHit[(int)Direction.Left]))
            {
                var pos = new Vector3(tile.transform.position.x - 0.5f, 1, tile.transform.position.z - 0.5f);
                Instantiate(corner, pos, Quaternion.Euler(0, 0, 0));
            }
        }
        if (!raycastHit[(int)Direction.UpLeft])
        {
            if ((!raycastHit[(int)Direction.Up] && !raycastHit[(int)Direction.Left]) || (raycastHit[(int)Direction.Up] && raycastHit[(int)Direction.Left]))
            {
                var pos = new Vector3(tile.transform.position.x - 0.5f, 1, tile.transform.position.z + 0.5f);
                Instantiate(corner, pos, Quaternion.Euler(0, 0, 0));
            }
        }

    }
}
