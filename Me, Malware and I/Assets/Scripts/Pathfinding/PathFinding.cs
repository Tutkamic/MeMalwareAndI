using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using System.Linq;

public class PathFinding : MonoBehaviour
{
    [SerializeField] GameObject nodeVisual;
    [SerializeField] LayerMask layermask;
    private int width;
    private int height;
    private float cellSize = 1.0f;
    public Grid grid;
    private List<FloorTile> floortiles;

    private List<PathNode> openList;
    private List<PathNode> closedList;

    private const int MoveStraightCost = 10;
    private const int MoveDiagonalCost = 14;

    private void Awake()
    {
        floortiles = FindObjectsOfType<FloorTile>().ToList();
        CreateGrid();
    }

    void Start()
    {
        CreateGrid();
    }


    private void CreateGrid()
    {
        var lastTileInX = floortiles.OrderBy(t => t.gameObject.transform.position.x).LastOrDefault();
        var lastTileInZ = floortiles.OrderBy(t => t.gameObject.transform.position.z).LastOrDefault();

        width = Mathf.FloorToInt(lastTileInX.transform.position.x) + 1;
        height = Mathf.FloorToInt(lastTileInZ.transform.position.z) + 1;

        grid = new Grid(width, height, cellSize);

        for (int i = 0; i < width; i++)
            for (int j = 0; j < height; j++)
            {
                Vector3 nodePos = new Vector3(transform.position.x + i, 0, transform.position.z + j);
                var visual = Instantiate(nodeVisual, nodePos, Quaternion.identity);
                visual.transform.parent = gameObject.transform;

                var raycastHit = Physics.Raycast(new Vector3(transform.position.x + i, 0.5f, transform.position.z + j), new Vector3(0, -1, 0), 1, layermask);
                if (raycastHit)
                {
                    SetGridNodesDefaultParameters(i, j);
                }
            }
    }


    public PathNode GetGridNode(int w, int h)
    {
        return grid.GetGridNode(w, h);
    }

    public List<PathNode> FindPath(PathNode startNode, PathNode endNode)
    {
        for (int i = 0; i < width; i++)
            for (int j = 0; j < height; j++)
                grid.GetGridNode(i, j).SetWalkable(false);

        openList = new List<PathNode> { startNode };
        closedList = new List<PathNode>();

        for (int i = 0; i < width; i++)
            for (int j = 0; j < height; j++)
            {
                var raycastHit = Physics.Raycast(new Vector3(transform.position.x + i, 0.5f, transform.position.z + j), new Vector3(0, -1, 0), 1, layermask);
                if (raycastHit)
                {
                    SetGridNodesDefaultParameters(i, j);
                }
            }

        startNode.SetGCost(0);
        startNode.SetHCost(CalculateDistnceCost(startNode, endNode));
        startNode.CalulateFCost();

        while (openList.Count > 0)
        {
            PathNode currentNode = GetLowestFCostNode(openList);
            if (currentNode == endNode)
                //Reached end node
                return CalculatePath(endNode);

            openList.Remove(currentNode);
            closedList.Add(currentNode);

            foreach (PathNode neighbour in GetNeighbourList(currentNode))
            {
                if (closedList.Contains(neighbour)) continue;

                int newGCost = currentNode.gCost + CalculateDistnceCost(currentNode, neighbour);
                if(newGCost < neighbour.gCost)
                {
                    neighbour.cameFromNode = currentNode;
                    neighbour.SetGCost(newGCost);
                    neighbour.SetHCost(CalculateDistnceCost(neighbour, endNode));
                    neighbour.CalulateFCost();
                }
                if (!openList.Contains(neighbour))  openList.Add(neighbour);
            }
        }
        //out of nodes on the openlist

        return null;
    }

    private void SetGridNodesDefaultParameters(int i, int j)
    {
        grid.GetGridNode(i, j).SetWalkable(true);
        grid.GetGridNode(i, j).SetGCost(int.MaxValue);
        grid.GetGridNode(i, j).CalulateFCost();
        grid.GetGridNode(i, j).cameFromNode = null;
    }


    private List<PathNode> GetNeighbourList(PathNode currentNode)
    {
        List<PathNode> neighbourList = new List<PathNode>();

        if (currentNode.x - 1 >= 0)
        {
            if (grid.GetGridNode(currentNode.x - 1, currentNode.z).isWalkable)
                neighbourList.Add(GetGridNode(currentNode.x - 1, currentNode.z)); //Left
            if (currentNode.z - 1 >= 0 && 
                grid.GetGridNode(currentNode.x - 1, currentNode.z - 1).isWalkable &&
                grid.GetGridNode(currentNode.x - 1, currentNode.z).isWalkable &&
                grid.GetGridNode(currentNode.x, currentNode.z - 1).isWalkable)
                neighbourList.Add(GetGridNode(currentNode.x - 1, currentNode.z - 1)); //Left down
            if (currentNode.z + 1 < grid.GetHeight() && 
                grid.GetGridNode(currentNode.x - 1, currentNode.z + 1).isWalkable &&
                grid.GetGridNode(currentNode.x - 1, currentNode.z).isWalkable &&
                grid.GetGridNode(currentNode.x, currentNode.z + 1).isWalkable) 
                neighbourList.Add(GetGridNode(currentNode.x - 1, currentNode.z + 1)); //Left up
        }
        if (currentNode.x + 1 < grid.GetWidth())
        {
            if (grid.GetGridNode(currentNode.x + 1, currentNode.z).isWalkable)
                neighbourList.Add(GetGridNode(currentNode.x + 1, currentNode.z)); //Right
            if (currentNode.z - 1 >= 0 && 
                grid.GetGridNode(currentNode.x + 1, currentNode.z - 1).isWalkable &&
                grid.GetGridNode(currentNode.x + 1, currentNode.z).isWalkable &&
                grid.GetGridNode(currentNode.x, currentNode.z - 1).isWalkable)
                neighbourList.Add(GetGridNode(currentNode.x + 1, currentNode.z - 1)); //Right down
            if (currentNode.z + 1 < grid.GetHeight() && 
                grid.GetGridNode(currentNode.x + 1, currentNode.z + 1).isWalkable &&
                grid.GetGridNode(currentNode.x + 1, currentNode.z).isWalkable &&
                grid.GetGridNode(currentNode.x, currentNode.z + 1).isWalkable)
                neighbourList.Add(GetGridNode(currentNode.x + 1, currentNode.z + 1)); //Right up
        }
        if (currentNode.z - 1 >= 0 && grid.GetGridNode(currentNode.x, currentNode.z - 1).isWalkable) neighbourList.Add(GetGridNode(currentNode.x, currentNode.z - 1)); //Down
        if (currentNode.z + 1 < grid.GetHeight() && grid.GetGridNode(currentNode.x, currentNode.z + 1).isWalkable) neighbourList.Add(GetGridNode(currentNode.x, currentNode.z + 1)); //Up

        return neighbourList;
    }

    public int CalculatePathCost(List<PathNode> path)
    {
        int cost = 0;
        for (int i = 0; i < path.Count - 1; i++)
            cost += CalculateDistnceCost(path[i], path[i + 1]);

        return cost;
    }

    private List<PathNode> CalculatePath(PathNode endNode)
    {
        List<PathNode> path = new List<PathNode>();
        path.Add(endNode);
        PathNode currentNode = endNode;

        while (currentNode.cameFromNode != null)
        {
            path.Add(currentNode.cameFromNode);
            currentNode = currentNode.cameFromNode;
        }
        path.Reverse();
        return path;
    }

    private PathNode GetLowestFCostNode(List<PathNode> pathNodeList)
    {
        PathNode lowestFCostNode = pathNodeList[0];
        for (int i = 0; i < pathNodeList.Count; i++)
            if (pathNodeList[i].fCost < lowestFCostNode.fCost) lowestFCostNode = pathNodeList[i];

        return lowestFCostNode;
    }

    public int CalculateDistnceCost(PathNode a, PathNode b)
    {
        int xDistance = Mathf.Abs(a.x - b.x);
        int zDistance = Mathf.Abs(a.z - b.z);
        int remain = Mathf.Abs(xDistance - zDistance);
        return MoveDiagonalCost * Mathf.Min(xDistance, zDistance) + MoveStraightCost * remain;
    }

}
